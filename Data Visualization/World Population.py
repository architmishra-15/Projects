# -*- coding: utf-8 -*-
"""world_pop_datarep.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CWH158UwLdOj16FxH7vR5fI4zd9zDJrX
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from matplotlib.colors import LinearSegmentedColormap
from matplotlib import mlab
import matplotlib as mpl
import geopandas as gpd
import numpy as np
import matplotlib.path as mpath
import matplotlib.patches as patches

map = gpd.read_file('/content/copy_4.shp')
map.drop(columns=['featurecla', 'cartodb _2'], inplace=True)
map.rename(columns={'NAME_LONG': 'country'}, inplace=True)
map['country'] = map['country'].str.lower()
map.plot()

map.head()

df = pd.read_csv('/content/world_population_data.csv')
df['country'] = df['country'].str.lower()
df.head(15)

merge = map.merge(df, on='country', how = 'left')

merge.shape[0]

merge = merge.dropna(subset=['country'], how='all')
merge['2023 population'].min()

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.path as mpath
import matplotlib.patches as patches
import matplotlib as mpl
from matplotlib.colors import LinearSegmentedColormap, LogNorm

# Sample data and preparation (assuming gdf, custom_cmap, norm are defined)
na_color = 'grey'
vmin = 1935.0
vmax = 1428627663.0

# Create a logarithmic normalization object
norm = LogNorm(vmin=vmin, vmax=vmax)

# Define a colormap with adjusted color stops for better distribution
custom_cmap = LinearSegmentedColormap.from_list(
    'custom_colormap',
    [(0, 'red'), (0.2, 'orange'), (0.4, 'yellow'), (0.6, 'green'), (0.8, 'cyan'), (1, 'blue')],
    N=256
)
custom_cmap.set_bad(na_color)

fig, ax = plt.subplots(1, figsize=(12, 12))
ax.set_title('World Population as of 2023', fontdict={'fontsize': 25, 'fontweight': 10, 'color': 'black'}, pad=0.01)

# Create the colorbar
orientation = "vertical"  # Change to "horizontal" if needed
colorbar_fraction = 0.03  # Adjust this value to change the length of the colorbar
cb = fig.colorbar(mpl.cm.ScalarMappable(norm=norm, cmap=custom_cmap), ax=ax, label='Population', orientation=orientation, fraction=colorbar_fraction, pad=0.01)
cb.outline.set_visible(False)

# Extend colorbar
bot = -0.05
top = 1.05

# Upper bound
xy_upper = np.array([[0, 1], [0, top], [1, top], [1, 1]])
if orientation == "horizontal":
    xy_upper = xy_upper[:, ::-1]

color = cb.cmap(cb.norm(vmax))
patch_upper = patches.PathPatch(
    mpath.Path(xy_upper, [mpath.Path.MOVETO, mpath.Path.CURVE4, mpath.Path.CURVE4, mpath.Path.CURVE4]),
    facecolor=color,
    linewidth=0,
    antialiased=False,
    transform=cb.ax.transAxes,
    clip_on=False,
)
cb.ax.add_patch(patch_upper)

# Lower bound
xy_lower = np.array([[0, 0], [0, bot], [1, bot], [1, 0]])
if orientation == "horizontal":
    xy_lower = xy_lower[:, ::-1]

color = cb.cmap(cb.norm(vmin))
patch_lower = patches.PathPatch(
    mpath.Path(xy_lower, [mpath.Path.MOVETO, mpath.Path.CURVE4, mpath.Path.CURVE4, mpath.Path.CURVE4]),
    facecolor=color,
    linewidth=0,
    antialiased=False,
    transform=cb.ax.transAxes,
    clip_on=False,
)
cb.ax.add_patch(patch_lower)

# Outline
xy_outline = np.array([[0, 0], [0, bot], [1, bot], [1, 0], [1, 1], [1, top], [0, top], [0, 1], [0, 0]])
if orientation == "horizontal":
    xy_outline = xy_outline[:, ::-1]

curve = [mpath.Path.MOVETO, mpath.Path.CURVE4, mpath.Path.CURVE4, mpath.Path.CURVE4, mpath.Path.LINETO,
         mpath.Path.CURVE4, mpath.Path.CURVE4, mpath.Path.CURVE4, mpath.Path.LINETO]
path = mpath.Path(xy_outline, curve, closed=True)

patch_outline = patches.PathPatch(
    path, facecolor="None", lw=1, transform=cb.ax.transAxes, clip_on=False
)
cb.ax.add_patch(patch_outline)
ax.axis('off')

# Plot the data (assuming merge is defined)
merge.plot(column='2023 population', cmap=custom_cmap, norm=norm, linewidth=0.5, ax=ax, edgecolor='0.2', legend=False, missing_kwds={'color': na_color}, label='Population')

plt.show()

